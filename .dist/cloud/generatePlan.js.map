{"version":3,"names":[],"mappings":"","sources":["cloud/generatePlan.js"],"sourcesContent":["import _ from 'lodash';\nimport uuid from 'uuid';\n\nimport buildLog from './buildLog';\n\nimport gt from 'generator-trees';\n\nconst {g, p} = gt;\n\nconst MAX_CONCURRENTLY_GENERATED_CLUSTERS = 5;\n\nmodule.exports = (cloud, providers, logFn, request, discoveryEtcdApiRoot) => {\n  const {log, start, ok, bad} = buildLog(logFn, 'Generate');\n\n  const {\n    locations,\n    configuration\n  } = cloud;\n\n  start('Plan');\n\n  const promise = initializePlan()\n          .then(defineClusters)\n          .then(plan => {\n            ok('Plan', {plan});\n            return plan;\n          });\n\n  promise.catch(error => {\n    return bad('Plan', {error});\n  });\n\n  return promise;\n\n  function initializePlan() {\n    return new Promise((resolve, reject) => {\n      const plan = {\n        cloudID: uuid.v4(),\n        definition: cloud\n      };\n\n      resolve(plan);\n    });\n  }\n\n  function defineClusters(plan) {\n    return new Promise((resolve, reject) => {\n      const clusterArray = _.flatten(_.map(locations, (locations, providerName) => {\n        return _.map(locations, location => {\n          return {\n            id: uuid.v4(),\n            providerName,\n            location,\n            machineCount: _.reduce(configuration, (count, roleCount) => { return count + roleCount; }, 0)\n          };\n        });\n      }));\n\n      const clusters = _.reduce(clusterArray, (clusters, cluster) => {\n        clusters[cluster.id] = cluster;\n        return clusters;\n      }, {});\n\n      const machineCount = _.reduce(clusters, (count, cluster) => count + cluster.machineCount, 0);\n      log({type: 'Machines', args: [{machineCount}]});\n\n      start('Clusters', {clusters});\n\n      p.async(\n        MAX_CONCURRENTLY_GENERATED_CLUSTERS,\n        g.map(g.toGenerator(clusterArray), assignEtcdUrl),\n        (cluster, generatedSoFar) => { })\n      .then(() => {\n        plan.clusters = clusters;\n        ok('Clusters', {clusters});\n        resolve(plan);\n      }, reject);\n\n      function assignEtcdUrl(cluster) {\n        return new Promise((resolve, reject) => {\n          start('Cluster', {cluster});\n          request(`${discoveryEtcdApiRoot}/new`, (error, response, discoveryURL) => {\n            if (error) {\n              reject(bad('Cluster', {error, cluster}));\n              return false;\n            }\n\n            cluster.discoveryURL = discoveryURL;\n            cluster.machineGenerator = getMachineGenerator(cluster);\n\n            ok('Cluster', {cluster});\n            resolve(plan);\n          });\n        });\n      }\n    });\n  }\n\n  function getMachineGenerator(cluster) {\n    return () => g.interleave(\n                  g.map(\n                    g.toGenerator(_.map(configuration, (value, roleName) => { return [roleName, value]; })),\n                    configuration => {\n                      const [roleName, value] = configuration;\n\n                      if (typeof value === 'number') {\n                        return g.take((function*() {\n                          while (true) {\n                            yield generateMachine(cluster, roleName);\n                          }\n                        })(), value);\n                      }\n                      else throw new Error('Can\\'t handle non-number role values yet!');\n                    }));\n  }\n\n  function generateMachine(cluster, roleName) {\n    return {\n      id: uuid.v4(),\n      roleName,\n      cluster,\n      generatedAt: new Date()\n    };\n  }\n};"],"file":"cloud/generatePlan.js","sourceRoot":"/source/"}