{"version":3,"names":[],"mappings":"","sources":["cloud/executePlan.js"],"sourcesContent":["import buildLog from './buildLog';\n\nimport templates from '../templates';\n\nimport _ from 'lodash';\nimport gt from 'generator-trees';\n\nvar fs = require('fs');\n\nconst {g, p} = gt;\n\nmodule.exports = (plan, providers, logFn) => {\n  const {log, start, ok, bad} = buildLog(logFn, 'Execute');\n\n  const {\n    cloudID,\n    definition,\n    clusters\n  } = plan;\n\n  return launch();\n\n  function launch() {\n    return new Promise((resolve, reject) => {\n      start('Plan');\n\n      const clustersByProvider = _.groupBy(plan.clusters, cluster => { return cluster.providerName; });\n\n      const launchPromise =\n        Promise\n          .all(_.map(clustersByProvider, launchProviderClusters))\n          .then(providerClusters => {\n            const clusters = _.reduce(providerClusters, (result, clusters) => {\n              _.each(clusters, (cluster, id) => {\n                result[id] = cluster;\n                cluster.machineCount = _.keys(cluster.machines).length;\n              });\n\n              return result;\n            }, {});\n\n            const cloud = {\n              id: cloudID,\n              clusters,\n              clusterCount: _.keys(clusters).length,\n              definition: definition\n            };\n\n            ok('Plan', {cloud});\n            resolve(cloud);\n          });\n\n      launchPromise.catch(error => {\n        reject(bad('Plan', {error}));\n      });\n\n      return launchPromise;\n    });\n  }\n\n  function launchProviderClusters(clusters, providerName) {\n    return new Promise((resolve, reject) => {\n      const provider = providers[providerName],\n            launchedClusters = _.reduce(clusters, (result, cluster) => {\n              const {id, location, discoveryURL} = cluster;\n\n              result[id] = {\n                id,\n                discoveryURL,\n                location,\n                machines: {},\n                provider: providerName\n              };\n\n              return result;\n            }, {});\n\n      start('Provider', {providerName});\n\n      p.async(\n        provider.api.MAX_CONCURRENT_CALLS,\n        g.map(\n          g.interleave(\n            g.map(g.toGenerator(clusters), cluster => cluster.machineGenerator())\n          ),\n          machineDef => new Promise((resolve, reject) => {\n            const {id, roleName, cluster, generatedAt} = machineDef,\n                  {id: clusterID, location, providerName, discoveryURL} = cluster;\n\n            const size = '512mb',\n                  image = 'coreos-stable';\n\n            const files = getFiles(id, roleName),\n                  metadata = _.map({id, clusterID, provider: providerName, location, size, image, roleName, generatedAt}, (value, key) => `${key}=${value}`).join(','),\n                  userData = templates.cloudConfig.render({discoveryURL, metadata, files});\n\n            const machine = {\n              id,\n              clusterID,\n              provider: providerName,\n              location,\n              size,\n              image,\n              roleName,\n              keys: definition.authorizations,\n              generatedAt,\n              userData\n            };\n\n            start('Machine', {machine});\n\n            provider\n              .api\n              .createMachine(machine)\n              .then(\n                response => {\n                  machine.response = response;\n                  machine.providerData = response;\n                  ok('Machine', {machine, machineDef});\n                  resolve(machine);\n                },\n                error => reject(bad('Machine', {machine, machineDef, error}))\n              );\n          })),\n        (machine, machinesGeneratedSoFar) => {\n          launchedClusters[machine.clusterID].machines[machine.id] = _.pick(machine, ['size', 'image', 'roleName', 'generatedAt', 'response', 'id', 'providerData']);\n        }\n      )\n      .then(\n        count => {\n          ok('Provider', {providerName});\n          resolve(launchedClusters);\n        },\n        error => reject(bad('Provider', {providerName, error}))\n      );\n    });\n  }\n\n  function getFiles(id, roleName) {\n    const {roles} = definition,\n          containers = _.map(roles[roleName], roleName => definition.containers[roleName]);\nconsole.log({containers});\n    const bootstrap = {\n      path: '/home/core/bootstrap.sh',\n      owner: 'core',\n      permissions: '0700',\n      content: indent(templates.bootstrap.render({\n        services: _.map(containers, getServices)\n      }),\n      '      ')\n    };\n\n    var util = {\n      path: '/home/core/util.sh',\n      owner: 'core',\n      permissions: '0700',\n      content: indent(templates.util_sh, '      ')\n    };\n\n    return [\n      bootstrap,\n      util\n    ].concat(_.map(containers, makeFileRecord));\n\n    function getServices({container: containerName}) {\n      const secrets = getSecrets(containerName);\n\n      let isGlobal = _.contains(definition.roles.$all || [], containerName);\n\n      containerName = containerName + (isGlobal ? '' : '@');\n\n      const fileName = `${containerName}.service`,\n            name = `${containerName}${isGlobal ? '' : id}`;\n\n      console.log('secrets', secrets);\n      return {\n        name,\n        fileName,\n        secrets\n      };\n    }\n\n    function getSecrets(containerName) {\n      const container = definition.containers[containerName],\n            secrets = container.secrets || [];\n\n      console.log(container, secrets);\n\n      return _.map(secrets, (definition, name) => {\n        const {type} = definition;\n\n        if (type === 'x509') return generate509CertificateCommand(name, definition);\n        throw new Error(`Unknown secret type: ${type}`);\n      });\n\n      function generate509CertificateCommand(name, definition) {\n        const subject = `/CN=${id}`,\n              keyName = `${name}/key`,\n              certificateName = `${name}/crt`,\n              days = 365,\n              algorithm = 'rsa',\n              bits = 2048;\n\n        return {\n          generateSecretCommand: `mkdir -p ~/secrets/${name} && openssl req -x509 -nodes -days ${days} -newkey ${algorithm}:${bits} -keyout ${keyLocation} -out ${certificateLocation} -subj \\\"${subject}\\\"`\n        };\n      }\n    }\n\n    function makeFileRecord(container) {\n      let containerName = container.container,\n          isGlobal = _.contains(definition.roles.$all || [], containerName),\n          template = isGlobal ? templates.containerService : templates['container@Service'],\n          serviceName = containerName + (isGlobal ? '' : '@'),\n          options = computeOptions(container);\n\n      if (containerName === 'cadvisor' && !options) options = '-v /:/rootfs:ro -v /var/run:/var/run:rw -v /sys:/sys:ro -v /var/lib/docker:/var/lib/docker:ro -p 8080:8080';\n\n      // fix these names!\n      // containerName = getQualifiedContainerName(containerName);\n      containerName = container.name;\n\n      const service = {\n        name: containerName,\n        content: template.render({\n          serviceName,\n          containerName,\n          statsContainerName: containerName.replace('/', '_'),\n          roleName,\n          options,\n          isGlobal\n        })\n      };\n\n      return {\n        path: '/home/core/' + serviceName + '.service',\n        owner: 'core',\n        permissions: '0600',\n        content: indent(service.content, '      ')\n      };\n    }\n  }\n\n  function computeOptions(container) {\n    if (container.options) return container.options;\n\n    const {environment, ports, volumes} = container;\n\n    return _.compact([\n      _.map(environment,  (value, key) => `-e ${key}=${value}`).join(' '),\n      _.map(ports,        (from, to) =>   `-p ${to}${from === true ? '' : (':' + from)}`).join(' '),\n      _.map(volumes,      (from, to) =>   `-v ${to}${from === true ? '' : (':' + from)}`).join(' ')\n    ]).join(' ');\n  }\n\n  // function getQualifiedContainerName(containerName) {\n  //   if (containerName === 'cadvisor') return 'google/cadvisor';\n\n  //   if (!definition.containers) return containerName;\n\n  //   const container = definition.containers[containerName];\n\n  //   if (!container) return containerName;\n\n  //   return container.container || containerName;\n  // }\n};\n\nfunction indent(s, i) {\n  return s.replace(/^/gm, i);\n}"],"file":"cloud/executePlan.js","sourceRoot":"/source/"}