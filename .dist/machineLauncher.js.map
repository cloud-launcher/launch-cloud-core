{"version":3,"names":[],"mappings":"","sources":["machineLauncher.js"],"sourcesContent":["var _ = require('lodash');\n\n// Creates a machine launcher\n// provider is a function that takes a\n\nmodule.exports = (provider, log, concurrentLaunches) => {\n  var launches = {inProgress: 0, next: 0},\n      availableProviders = [];\n\n  concurrentLaunches = concurrentLaunches || 10;\n\n  for (var i = 0; i < concurrentLaunches; i++) availableProviders.push(provider);\n\n  return { launch };\n\n  // Currently can only have one of these running\n  // machines is a generator function that yields machine definitions\n  // function launch(machines) {\n  //   while (true) {\n  //     var result = machines.next(),\n  //         machine = result.value;\n\n  //     var promise = new Promise();\n  //   }\n  // }\n\n\n  function launch(machines, progress) {\n    return new Promise((launchResolve, reject) => {\n      var q = machines();\n      launchMachines();\n\n      function launchMachines() {\n        if (machines.remaining === 0) {\n          if (availableProviders.length == concurrentLaunches) return launchResolve(machines);\n          else {\n            qLaunch();\n            return;\n          }\n        }\n\n        var takeCount = Math.min(availableProviders.length, q.length);\n        if (takeCount > 0) assignToProviders(takeCount);\n      }\n\n      function qLaunch() { setTimeout(launchMachines, 0); }\n\n      function* assignToProviders(takeCount) {\n        return map(zip(toGenerator(take(integers, takeCount), take(machines, takeCount), take(availableProviders, takeCount))), pair => {\n          var index = pair[0],\n              machine = pair[1],\n              provider = pair[2];\n\n          return {\n            remaining: takeCount - index, // notify caller how many more values are safe to generate (ie. that we have available providers for)\n            promise: new Promise((resolve, reject) => {\n              launch(machine, provider)\n                .then(result => {\n                  var response = result.response,\n                      provider = result.provider;\n\n                  availableProviders.push(provider); // Promises should have an onFinally to avoid this duplication\n\n                  machine.providerResponse = response;\n\n                  resolve(machine);\n                }, error => {\n                  var provider = error.provider;\n\n                  availableProviders.push(provider);\n\n                  reject(error, machine);\n                });\n            })\n          };\n        });\n\n\n        // _.chain(q.splice(0, takeCount))\n        //  .zip(availableProviders.splice(0, takeCount))\n        //  .each(pair => {\n        //     var machine = pair[0],\n        //         provider = pair[1];\n\n        //     launch(machine, provider)\n        //       .then(result => {\n        //         var response = result.response,\n        //             provider = result.provider;\n\n        //         machine.response = response;\n\n        //         progress.launched(machine);\n\n        //         availableProviders.push(provider); // Promises should have an onFinally to avoid this duplication\n        //         qLaunch();\n        //       }, error => {\n        //         progress.error(error);\n\n        //         var provider = error.provider;\n\n        //         availableProviders.push(provider);\n        //         qLaunch();\n        //       });\n        //  });\n      }\n\n      function launch(machine, provider) {\n        return new Promise((resolve, reject) => {\n          provider.createMachine(machine)\n                  .then(response => resolve({response, provider}),\n                        error => reject({error, provider}));\n        });\n      }\n    });\n  }\n};\n\n// var\n\n// for (var )\n\n// function take(generator, count) {\n//   var ret = [];\n//   for (var i = 0; i < count; i++) {\n//     ret.push(generator.next());\n//   }\n//   return ret;\n// }\n\n// launch(function*() {\n\n// });\n\n// function* (clusters) {\n//   var clusterGenerators = yield* clusters();\n\n//   for (var machineGenerator of queue()) {\n//     var result = machineGenerator.next();\n//     if (result.done) removeGenerator(generator); // what is notifyGenerators?\n//     yield result.value;\n//   });\n\n//   var next = 0;\n//   function* queue() {\n//     while (q.length > 0) {\n//       var generator = q[next];\n//       yield generator;\n//       next\n//     }\n//   }\n\n//   function removeGenerator(generator) {\n\n//   }\n// }\n\n// function* gMap(array, transform) {\n//   for (var i = 0; i < array.length; i++) {\n//     yield transform(array[i]);\n//   }\n// }\n\n// function* aToG(array) {\n//   for (var i = 0; i < array.length; i++) {\n//     yield array[i];\n//   }\n// }\n\nmodule.exports.name = 'digitalocean';"],"file":"machineLauncher.js","sourceRoot":"/source/"}